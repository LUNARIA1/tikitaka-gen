<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RisuChat Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style id="custom-font-styles"></style>
    <style>
        :root {
            --char-bubble-bg: #f1f0f0;
            --user-bubble-bg: #fef01b;

            --char-font-family: 'Malgun Gothic', sans-serif;
            --char-font-size: 14px;
            --char-font-color: #000000;
            --char-font-weight: normal;
            --char-italic-font-family: 'Malgun Gothic', sans-serif;
            --char-italic-font-size: 14px;
            --char-italic-font-color: #555555;
            --char-italic-font-weight: normal;
            --char-double-quote-font-family: 'Malgun Gothic', sans-serif;
            --char-double-quote-font-size: 14px;
            --char-double-quote-font-color: #000000;
            --char-double-quote-font-weight: normal;
            --char-single-quote-font-family: 'Malgun Gothic', sans-serif;
            --char-single-quote-font-size: 14px;
            --char-single-quote-font-color: #000000;
            --char-single-quote-font-weight: normal;

            --user-font-family: 'Malgun Gothic', sans-serif;
            --user-font-size: 14px;
            --user-font-color: #000000;
            --user-font-weight: normal;
            --user-italic-font-family: 'Malgun Gothic', sans-serif;
            --user-italic-font-size: 14px;
            --user-italic-font-color: #555555;
            --user-italic-font-weight: normal;
            --user-double-quote-font-family: 'Malgun Gothic', sans-serif;
            --user-double-quote-font-size: 14px;
            --user-double-quote-font-color: #000000;
            --user-double-quote-font-weight: normal;
            --user-single-quote-font-family: 'Malgun Gothic', sans-serif;
            --user-single-quote-font-size: 14px;
            --user-single-quote-font-color: #000000;
            --user-single-quote-font-weight: normal;
        }

        body {
            font-family: 'Malgun Gothic', sans-serif;
            background-color: #f0f2f5;
            margin: 0;
            padding: 20px;
            display: flex;
            gap: 20px;
        }

        #controls {
            width: 400px;
            background: #fff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            height: fit-content;
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-sizing: border-box;
        }

        #controls h2, #controls h3 {
            margin-top: 0;
            margin-bottom: 10px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        .control-group {
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 5px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .control-group input, .control-group select {
            width: calc(100% - 10px);
            padding: 5px;
            margin-bottom: 5px;
        }
        
        .custom-width-controls input[type="number"] {
             width: 80px;
             display: inline-block;
        }

        .font-style-controls fieldset {
            border: 1px solid #ccc;
            padding: 10px;
            margin-top: 10px;
        }
        .font-style-controls legend {
            font-weight: bold;
        }
        .font-style-controls .style-row {
            display: grid;
            grid-template-columns: 80px 1fr 50px;
            gap: 5px;
            align-items: center;
            margin-bottom: 5px;
        }

        button {
            padding: 10px;
            border: none;
            background-color: #007bff;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover { background-color: #0056b3; }
        
        #chat-wrapper {
            flex: 1;
            min-width: 0;
        }
        
        #chat-container {
            width: 100%;
            background-color: #b2c7d9;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 15px;
            border-radius: 8px;
        }
        
        .message-container {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            max-width: 85%;
            transition: background-color 0.2s;
        }

        .message-container.char { align-self: flex-start; }
        .message-container.user { align-self: flex-end; }

        .profile-pic {
            width: 40px; height: 40px; border-radius: 50%;
            background-color: #e0e0e0; flex-shrink: 0; object-fit: cover;
        }
        .message-container.consecutive .profile-pic { visibility: hidden; }

        .message-bubble {
            padding: 10px 15px; border-radius: 18px;
            white-space: pre-wrap; word-break: break-word;
        }
        .message-bubble em { font-style: italic; }

        .message-container.char .message-bubble { background-color: var(--char-bubble-bg); border-top-left-radius: 0; font-family: var(--char-font-family); font-size: var(--char-font-size); color: var(--char-font-color); font-weight: var(--char-font-weight); }
        .message-container.char em { font-family: var(--char-italic-font-family); font-size: var(--char-italic-font-size); color: var(--char-italic-font-color); font-weight: var(--char-italic-font-weight); }
        .message-container.char .double-quoted-text { font-family: var(--char-double-quote-font-family); font-size: var(--char-double-quote-font-size); color: var(--char-double-quote-font-color); font-weight: var(--char-double-quote-font-weight); }
        .message-container.char .single-quoted-text { font-family: var(--char-single-quote-font-family); font-size: var(--char-single-quote-font-size); color: var(--char-single-quote-font-color); font-weight: var(--char-single-quote-font-weight); }
        .message-container.user .message-bubble { background-color: var(--user-bubble-bg); border-top-right-radius: 0; font-family: var(--user-font-family); font-size: var(--user-font-size); color: var(--user-font-color); font-weight: var(--user-font-weight); }
        .message-container.user em { font-family: var(--user-italic-font-family); font-size: var(--user-italic-font-size); color: var(--user-italic-font-color); font-weight: var(--user-italic-font-weight); }
        .message-container.user .double-quoted-text { font-family: var(--user-double-quote-font-family); font-size: var(--user-double-quote-font-size); color: var(--user-double-quote-font-color); font-weight: var(--user-double-quote-font-weight); }
        .message-container.user .single-quoted-text { font-family: var(--user-single-quote-font-family); font-size: var(--user-single-quote-font-size); color: var(--user-single-quote-font-color); font-weight: var(--user-single-quote-font-weight); }

        body.capture-mode #chat-container .message-container { cursor: pointer; border: 2px dashed transparent; }
        body.capture-mode #chat-container .message-container:hover { background-color: rgba(0, 123, 255, 0.1); border-color: #007bff; }
        #chat-container .message-container.selected-for-capture { background-color: rgba(40, 167, 69, 0.2); border-color: #28a745; }
        #chat-container .message-container.capture-start { background-color: rgba(255, 193, 7, 0.3); border-color: #ffc107; }
        #capture-status { position: fixed; bottom: 20px; right: 20px; background-color: #dc3545; color: white; padding: 10px 20px; border-radius: 20px; font-weight: bold; display: none; z-index: 1001; align-items: center; gap: 15px; }
        body.capture-mode #capture-status { display: flex; }
        #capture-status-save-btn { padding: 5px 12px; background-color: #28a745; font-size: 13px; }

        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4); justify-content: center; align-items: center; }
        .modal-content { background-color: #fefefe; padding: 20px; border: 1px solid #888; width: 80%; max-width: 600px; border-radius: 10px; display: flex; flex-direction: column; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #eee; padding-bottom: 10px; margin-bottom: 15px; }
        .close-button { color: #aaa; font-size: 28px; font-weight: bold; cursor: pointer; }
        .regex-rule { display: flex; gap: 10px; margin-bottom: 10px; align-items: center; }
        .regex-rule input, .regex-rule textarea, #font-css-input { flex: 1; padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-family: inherit; }
        .regex-rule textarea, #font-css-input { resize: vertical; }
        #font-css-input { min-height: 200px; font-family: monospace; }
        .regex-rule button { padding: 5px 10px; background-color: #dc3545; }
        #add-regex-btn { width: 100%; margin-top: 10px; background-color: #28a745; }
        .modal-footer { margin-top: 15px; align-self: flex-end; }
        #split-download-links-container { display: flex; flex-direction: column; gap: 10px; max-height: 300px; overflow-y: auto; }
        .split-download-button { background-color: #28a745; }
        .split-download-button:disabled { background-color: #6c757d; cursor: not-allowed; }

        #mobile-toggle-btn {
            display: none; position: fixed; top: 20px; left: 0; z-index: 1002;
            background-color: rgba(0, 0, 0, 0.5); color: white; border: none; padding: 10px;
            border-radius: 0 8px 8px 0; cursor: pointer; font-size: 24px; line-height: 1;
        }
        #mobile-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.4); z-index: 1001;
        }

        @media (max-width: 768px) {
            body { flex-direction: column; padding: 10px; }
            #controls {
                position: fixed; top: 0; left: 0; width: 80%; max-width: 320px; height: 100vh; z-index: 1003;
                overflow-y: auto; transform: translateX(-100%); transition: transform 0.3s ease-in-out;
                border-radius: 0; box-shadow: 2px 0 10px rgba(0,0,0,0.2);
            }
            body.controls-visible #controls { transform: translateX(0); }
            #mobile-toggle-btn { display: block; }
            body.controls-visible #mobile-overlay { display: block; }
        }
    </style>
</head>
<body>

    <button id="mobile-toggle-btn">→</button>
    <div id="mobile-overlay"></div>

    <div id="controls">
        <h2>Control Panel</h2>
        <div class="control-group"><label for="json-upload">1. 채팅 파일 업로드 (.json)</label><input type="file" id="json-upload" accept=".json"></div>
        <div class="control-group"><h3>프로필 사진</h3><label for="char-pfp-upload">캐릭터 프로필</label><input type="file" id="char-pfp-upload" accept="image/*"><label for="user-pfp-upload">사용자 프로필</label><input type="file" id="user-pfp-upload" accept="image/*"></div>
        <div class="control-group"><h3>디자인 설정</h3><label for="chat-bg-color">채팅 배경 색상</label><input type="color" id="chat-bg-color" value="#b2c7d9"><label for="char-bubble-color">캐릭터 말풍선</label><input type="color" id="char-bubble-color" value="#f1f0f0"><label for="user-bubble-color">사용자 말풍선</label><input type="color" id="user-bubble-color" value="#fef01b"></div>
        <div class="control-group font-style-controls"><h3>텍스트 스타일</h3><div id="style-accordion"></div></div>
        <button id="open-regex-modal">정규식 치환 관리</button>
        <button id="open-font-modal">커스텀 폰트 관리</button>
        <div class="control-group">
            <h3>PNG로 저장</h3>
            <button id="toggle-capture-mode">구간 캡쳐 모드 시작/종료</button>
            <button id="save-capture" style="margin-top: 5px; background-color: #28a745;">선택 영역 저장</button>
            <div class="custom-width-controls" style="margin-top: 10px; border-top: 1px solid #eee; padding-top: 10px;"><label style="display: inline-block; font-weight: normal;"><input type="checkbox" id="custom-width-toggle" style="width: auto;"> 가로 사이즈 커스텀</label><input type="number" id="custom-width-input" value="500" min="300" disabled> px</div>
        </div>
    </div>

    <div id="chat-wrapper"><div id="chat-container"></div></div>
    <div id="capture-status"><span id="capture-status-text">캡쳐 모드 활성 중: 시작 블록을 선택하세요.</span><button id="capture-status-save-btn" style="display: none;">선택 영역 저장</button></div>
    <div id="regex-modal" class="modal"><div class="modal-content"><div class="modal-header"><h2>정규식 관리</h2><span class="close-button">&times;</span></div><div id="regex-rules-container"></div><button id="add-regex-btn">+</button><div class="modal-footer"><button id="save-regex-btn">저장 및 적용</button></div></div></div>
    <div id="font-modal" class="modal"><div class="modal-content"><div class="modal-header"><h2>커스텀 폰트 관리</h2><span class="close-button">&times;</span></div><p style="font-size: 13px; color: #555; margin-top:0;">아래에 <code>@font-face</code> CSS 규칙을 붙여넣으세요.</p><textarea id="font-css-input"></textarea><div class="modal-footer"><button id="save-font-btn">저장 및 적용</button></div></div></div>
    
    <!-- 분할 다운로드 모달 -->
    <div id="split-download-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>분할 다운로드</h2>
                <span class="close-button">&times;</span>
            </div>
            <p style="font-size: 13px; color: #555; margin-top:0;">이미지가 너무 길어 여러 부분으로 나뉘었습니다. 각 버튼을 클릭하여 다운로드하세요.</p>
            <div id="split-download-links-container"></div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        let chatData = null, charPfpSrc = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">C</text></svg>', userPfpSrc = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">U</text></svg>', regexRules = [], customFontCss = '', isCaptureMode = false, captureStartElement = null;
        const body = document.body, jsonUpload = document.getElementById('json-upload'), chatContainer = document.getElementById('chat-container'), charPfpUpload = document.getElementById('char-pfp-upload'), userPfpUpload = document.getElementById('user-pfp-upload'), root = document.documentElement, regexModal = document.getElementById('regex-modal'), openRegexModalBtn = document.getElementById('open-regex-modal'), saveRegexBtn = document.getElementById('save-regex-btn'), regexRulesContainer = document.getElementById('regex-rules-container'), fontModal = document.getElementById('font-modal'), openFontModalBtn = document.getElementById('open-font-modal'), fontCssInput = document.getElementById('font-css-input'), saveFontBtn = document.getElementById('save-font-btn'), toggleCaptureBtn = document.getElementById('toggle-capture-mode'), saveCaptureBtn = document.getElementById('save-capture'), captureStatusText = document.getElementById('capture-status-text'), captureStatusSaveBtn = document.getElementById('capture-status-save-btn'), chatBgColorInput = document.getElementById('chat-bg-color'), customWidthToggle = document.getElementById('custom-width-toggle'), customWidthInput = document.getElementById('custom-width-input'), mobileToggleBtn = document.getElementById('mobile-toggle-btn'), mobileOverlay = document.getElementById('mobile-overlay'), splitDownloadModal = document.getElementById('split-download-modal');

        loadChat({"type":"risuChat","ver":2,"data":{"message":[]}}); createStyleControls(); updateRegexModal();

        jsonUpload.addEventListener('change', (event) => { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (e) => { try { const json = JSON.parse(e.target.result); loadChat(json); } catch (error) { alert('유효하지 않은 JSON 파일입니다.'); console.error(error); } }; reader.readAsText(file); });
        charPfpUpload.addEventListener('change', (e) => handlePfpUpload(e, 'char')); userPfpUpload.addEventListener('change', (e) => handlePfpUpload(e, 'user'));
        chatBgColorInput.addEventListener('input', (e) => { chatContainer.style.backgroundColor = e.target.value; });
        document.getElementById('char-bubble-color').addEventListener('input', (e) => { root.style.setProperty('--char-bubble-bg', e.target.value); });
        document.getElementById('user-bubble-color').addEventListener('input', (e) => { root.style.setProperty('--user-bubble-bg', e.target.value); });
        
        function setupModal(modal, openBtn) { const closeBtn = modal.querySelector('.close-button'); if(openBtn) openBtn.onclick = () => { modal.style.display = 'flex'; }; closeBtn.onclick = () => { modal.style.display = 'none'; }; window.addEventListener('click', (event) => { if (event.target == modal) { modal.style.display = 'none'; } }); }
        setupModal(regexModal, openRegexModalBtn); setupModal(fontModal, openFontModalBtn); setupModal(splitDownloadModal, null);

        document.getElementById('add-regex-btn').onclick = () => addRegexRule();
        saveRegexBtn.onclick = () => { saveRegexRules(); regexModal.style.display = 'none'; renderChat(); };
        openFontModalBtn.onclick = () => { fontCssInput.value = customFontCss; fontModal.style.display = 'flex'; };
        saveFontBtn.onclick = () => { customFontCss = fontCssInput.value; document.getElementById('custom-font-styles').textContent = customFontCss; updateFontDropdowns(); fontModal.style.display = 'none'; };
        toggleCaptureBtn.addEventListener('click', () => { isCaptureMode = !isCaptureMode; body.classList.toggle('capture-mode', isCaptureMode); clearAllSelections(); if(isCaptureMode){ captureStatusText.textContent = "캡쳐 모드 활성 중: 시작 블록을 선택하세요."; captureStatusSaveBtn.style.display = 'none'; } });
        saveCaptureBtn.addEventListener('click', exportToPng); captureStatusSaveBtn.addEventListener('click', exportToPng); customWidthToggle.addEventListener('change', () => { customWidthInput.disabled = !customWidthToggle.checked; });
        
        function toggleMobileControls() { body.classList.toggle('controls-visible'); mobileToggleBtn.innerHTML = body.classList.contains('controls-visible') ? '←' : '→'; }
        mobileToggleBtn.addEventListener('click', toggleMobileControls); mobileOverlay.addEventListener('click', toggleMobileControls);

        chatContainer.addEventListener('click', (e) => {
            if (!isCaptureMode) return; const clickedMessage = e.target.closest('.message-container'); if (!clickedMessage) return;
            if (!captureStartElement) { clearAllSelections(); captureStartElement = clickedMessage; captureStartElement.classList.add('capture-start'); captureStatusText.textContent = "캡쳐 모드 활성 중: 끝 블록을 선택하세요."; captureStatusSaveBtn.style.display = 'none'; } 
            else { const allMessages = Array.from(chatContainer.querySelectorAll('.message-container')), startIndex = allMessages.indexOf(captureStartElement), endIndex = allMessages.indexOf(clickedMessage); document.querySelectorAll('.capture-start').forEach(el => el.classList.remove('capture-start')); const start = Math.min(startIndex, endIndex), end = Math.max(startIndex, endIndex); let selectedCount = 0; for (let i = start; i <= end; i++) { allMessages[i].classList.add('selected-for-capture'); selectedCount++; } captureStatusText.textContent = `${selectedCount}개 블록 선택됨`; captureStatusSaveBtn.style.display = 'inline-block'; captureStartElement = null; }
        });

        function loadChat(json) { if (json.type === 'risuChat' && json.data && Array.isArray(json.data.message)) { chatData = json.data.message; } else { alert('지원하지 않는 형식의 파일입니다.'); chatData = []; } renderChat(); }
        function handlePfpUpload(event, role) { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (e) => { if (role === 'char') charPfpSrc = e.target.result; else userPfpSrc = e.target.result; renderChat(); }; reader.readAsDataURL(file); }
        function processText(text) { let processedText = text; regexRules.forEach(rule => { try { processedText = processedText.replace(new RegExp(rule.in, 'g'), rule.out); } catch (e) { console.error("Invalid Regex:", rule.in, e); } }); processedText = processedText.trim(); const tempDiv = document.createElement('div'); tempDiv.textContent = processedText; processedText = tempDiv.innerHTML; processedText = processedText.replace(/\*(.*?)\*/g, '<em>$1</em>'); processedText = processedText.replace(/"(.*?)"/g, '<span class="double-quoted-text">"$1"</span>'); processedText = processedText.replace(/'(.*?)'/g, "<span class='single-quoted-text'>'$1'</span>"); return processedText; }
        function renderChat() { chatContainer.innerHTML = ''; if (!chatData || chatData.length === 0) { chatContainer.innerHTML = '<p style="text-align: center; color: #555;">왼쪽 컨트롤 패널에서 채팅 파일(.json)을 업로드해주세요.</p>'; return; } let lastRole = null; chatData.forEach((msg) => { const isConsecutive = msg.role === lastRole, container = document.createElement('div'); container.classList.add('message-container', msg.role); if (isConsecutive) container.classList.add('consecutive'); const pfp = document.createElement('img'); pfp.classList.add('profile-pic'); pfp.src = msg.role === 'char' ? charPfpSrc : userPfpSrc; const bubble = document.createElement('div'); bubble.classList.add('message-bubble'); bubble.innerHTML = processText(msg.data); if (msg.role === 'user') { container.appendChild(bubble); container.appendChild(pfp); } else { container.appendChild(pfp); container.appendChild(bubble); } chatContainer.appendChild(container); lastRole = msg.role; }); }
        function updateFontDropdowns() { const baseFonts = ['Malgun Gothic', 'Gulim', 'Dotum', 'Arial', 'Verdana']; const customFonts = new Set(); const fontRegex = /font-family:\s*['"]([^'"]+)['"]/g; let match; while ((match = fontRegex.exec(customFontCss)) !== null) { customFonts.add(match[1]); } const allFonts = [...baseFonts, ...Array.from(customFonts)]; const allSelects = document.querySelectorAll('#style-accordion select'); allSelects.forEach(select => { const currentValue = select.value; select.innerHTML = ''; allFonts.forEach(fontName => { const option = document.createElement('option'); option.value = fontName; option.textContent = fontName; select.appendChild(option); }); select.value = allFonts.includes(currentValue) ? currentValue : allFonts[0]; }); }
        function createStyleControls() { const container = document.getElementById('style-accordion'); const roles = [{ id: 'char', name: '캐릭터' }, { id: 'user', name: '사용자' }]; const textTypes = [{ id: '', name: '일반' }, { id: 'italic', name: '기울임 (*)' }, { id: 'double-quote', name: '큰따옴표 ("")' }, { id: 'single-quote', name: "작은따옴표 ('')" }]; roles.forEach(role => { const fieldset = document.createElement('fieldset'); const legend = document.createElement('legend'); legend.textContent = role.name; fieldset.appendChild(legend); textTypes.forEach(type => { const row = document.createElement('div'); row.className = 'style-row'; const typeLabel = document.createElement('span'); typeLabel.textContent = type.name; const controlsWrapper = document.createElement('div'); const prefix = `--${role.id}${type.id ? '-' + type.id : ''}-`; const fontSelect = document.createElement('select'); fontSelect.onchange = (e) => root.style.setProperty(prefix + 'font-family', e.target.value); const sizeInput = document.createElement('input'); sizeInput.type = 'number'; sizeInput.min = 8; sizeInput.max = 32; sizeInput.value = 14; sizeInput.oninput = (e) => root.style.setProperty(prefix + 'font-size', e.target.value + 'px'); const colorInput = document.createElement('input'); colorInput.type = 'color'; colorInput.value = type.id === 'italic' ? '#555555' : '#000000'; colorInput.oninput = (e) => root.style.setProperty(prefix + 'font-color', e.target.value); const boldCheckbox = document.createElement('input'); boldCheckbox.type = 'checkbox'; const boldLabel = document.createElement('label'); boldLabel.textContent = 'B'; boldLabel.style.fontWeight = 'bold'; boldLabel.prepend(boldCheckbox); boldCheckbox.onchange = (e) => root.style.setProperty(prefix + 'font-weight', e.target.checked ? 'bold' : 'normal'); controlsWrapper.append(fontSelect, sizeInput, colorInput, boldLabel); row.append(typeLabel, controlsWrapper); fieldset.appendChild(row); }); container.appendChild(fieldset); }); updateFontDropdowns(); }
        function addRegexRule(inVal = '', outVal = '') { const ruleDiv = document.createElement('div'); ruleDiv.className = 'regex-rule'; const inInput = document.createElement('input'); inInput.type = 'text'; inInput.placeholder = 'IN (찾을 패턴)'; inInput.value = inVal; inInput.className = 'regex-in'; const outInput = document.createElement('textarea'); outInput.placeholder = 'OUT (바꿀 내용)'; outInput.value = outVal; outInput.className = 'regex-out'; outInput.rows = 1; const removeBtn = document.createElement('button'); removeBtn.innerHTML = '&times;'; removeBtn.onclick = () => ruleDiv.remove(); ruleDiv.append(inInput, '→', outInput, removeBtn); regexRulesContainer.appendChild(ruleDiv); }
        function updateRegexModal() { regexRulesContainer.innerHTML = ''; regexRules.forEach(rule => addRegexRule(rule.in, rule.out)); }
        function saveRegexRules() { regexRules = []; document.querySelectorAll('.regex-rule').forEach(el => { const inVal = el.querySelector('.regex-in').value, outVal = el.querySelector('.regex-out').value; if (inVal) { try { new RegExp(inVal, 'g'); regexRules.push({ in: inVal, out: outVal }); } catch (e) { alert(`잘못된 정규식입니다: ${inVal}`); } } }); }
        function clearAllSelections() { document.querySelectorAll('.message-container').forEach(el => { el.classList.remove('selected-for-capture', 'capture-start'); }); captureStartElement = null; }

        async function populateSplitDownloadModal(pages, captureWidth) {
            const container = document.getElementById('split-download-links-container');
            container.innerHTML = ''; // Clear previous links

            for (let i = 0; i < pages.length; i++) {
                const btn = document.createElement('button');
                btn.textContent = `Part ${i + 1} / ${pages.length} 다운로드`;
                btn.className = 'split-download-button';
                btn.onclick = async () => {
                    btn.disabled = true;
                    btn.textContent = '다운로드 중...';
                    try {
                        await captureAndDownload(pages[i], `chat-capture-part-${i + 1}.png`, captureWidth);
                        btn.textContent = `다운로드 완료 ✓`;
                    } catch (e) {
                        btn.textContent = `오류 발생 - 재시도`;
                        btn.disabled = false;
                    }
                };
                container.appendChild(btn);
            }
            splitDownloadModal.style.display = 'flex';
        }

        async function captureAndDownload(nodesToCapture, filename, captureWidth) {
            const captureContent = document.createElement('div');
            Object.assign(captureContent.style, {
                width: captureWidth, padding: '20px', backgroundColor: window.getComputedStyle(chatContainer).backgroundColor,
                boxSizing: 'border-box', display: 'flex', flexDirection: 'column', gap: '15px',
            });
            nodesToCapture.forEach(node => captureContent.appendChild(node.cloneNode(true)));
            const captureWrapper = document.createElement('div');
            Object.assign(captureWrapper.style, { position: 'absolute', left: '-9999px', top: '0px', });
            captureWrapper.appendChild(captureContent);
            document.body.appendChild(captureWrapper);
            try {
                const canvas = await html2canvas(captureContent, { backgroundColor: null, useCORS: true });
                const link = document.createElement('a');
                link.download = filename;
                link.href = canvas.toDataURL('image/png');
                link.click();
            } finally {
                document.body.removeChild(captureWrapper);
            }
        }

        async function exportToPng() {
            const messagesToCapture = Array.from(document.querySelectorAll('.selected-for-capture'));
            if (messagesToCapture.length === 0) { alert('저장할 채팅 블록을 먼저 선택해주세요.'); return; }

            const MAX_CANVAS_HEIGHT = 16384;
            const captureWidth = (customWidthToggle.checked && customWidthInput.value) ? `${parseInt(customWidthInput.value, 10)}px` : `${chatContainer.offsetWidth}px`;

            const pages = [];
            const measureWrapper = document.createElement('div');
            Object.assign(measureWrapper.style, {
                position: 'absolute', left: '-9999px', top: '0px', width: captureWidth,
                padding: '20px', boxSizing: 'border-box', display: 'flex', flexDirection: 'column', gap: '15px',
            });
            document.body.appendChild(measureWrapper);

            for (const node of messagesToCapture) {
                const clone = node.cloneNode(true);
                measureWrapper.appendChild(clone);
                if (measureWrapper.scrollHeight > MAX_CANVAS_HEIGHT) {
                    measureWrapper.removeChild(clone);
                    pages.push([...measureWrapper.childNodes]);
                    measureWrapper.innerHTML = '';
                    measureWrapper.appendChild(clone);
                }
            }
            if (measureWrapper.childNodes.length > 0) {
                pages.push([...measureWrapper.childNodes]);
            }
            document.body.removeChild(measureWrapper);

            try {
                if (pages.length <= 1) {
                    await captureAndDownload(messagesToCapture, 'chat-capture.png', captureWidth);
                } else {
                    await populateSplitDownloadModal(pages, captureWidth);
                }
            } catch (error) {
                console.error('이미지 저장 중 오류 발생:', error);
                alert('이미지 저장에 실패했습니다. 콘솔을 확인해주세요.');
            }
        }
    });
    </script>
</body>
</html>
