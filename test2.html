<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zeta Chat Exporter (최종 기능 추가)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #121212;
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            width: 90%;
            max-width: 900px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        h1 {
            color: #ffffff;
            text-align: center;
            border-bottom: 2px solid #333;
            padding-bottom: 10px;
        }
        textarea, pre {
            width: 100%;
            box-sizing: border-box;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
            background-color: #2a2a2a;
            color: #e0e0e0;
            font-size: 14px;
            line-height: 1.6;
        }
        textarea {
            height: 250px;
            resize: vertical;
        }
        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            background-color: #1e1e1e;
            min-height: 100px;
        }
        .button-group {
            display: flex;
            gap: 10px;
            align-self: center;
        }
        button {
            padding: 12px 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background-color: #6200ea;
            color: white;
            transition: background-color 0.3s ease, opacity 0.3s ease;
        }
        button:hover:not(:disabled) {
            background-color: #7f39fb;
        }
        button:disabled {
            background-color: #333;
            color: #777;
            cursor: not-allowed;
        }
        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }
        .label {
            font-size: 18px;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>채팅 내용 정리 도구</h1>
        
        <label for="htmlInput" class="label">1. 여기에 HTML 코드를 붙여넣으세요:</label>
        <textarea id="htmlInput" placeholder="개발자 도구에서 복사한 HTML 코드를 여기에 붙여넣어 주세요..."></textarea>
        
        <button id="processBtn">대화 정리하기</button>
        
        <div class="result-header">
            <label for="output" class="label">2. 결과:</label>
            <div class="button-group">
                <button id="copyBtn" disabled>결과 복사</button>
                <button id="downloadJsonBtn" disabled>RISU AI용 JSON 다운로드</button>
            </div>
        </div>
        <pre id="output">변환된 대화 내용이 여기에 표시됩니다.</pre>
    </div>

    <script>
        // 추출된 대화 데이터를 저장할 변수 (전역 범위)
        let conversationData = [];

        const processBtn = document.getElementById('processBtn');
        const copyBtn = document.getElementById('copyBtn');
        const downloadJsonBtn = document.getElementById('downloadJsonBtn');
        const htmlInput = document.getElementById('htmlInput');
        const outputElement = document.getElementById('output');

        function processHtmlContent(element) {
            if (!element) return null;
            let rawHtml = element.innerHTML;
            let processedText = rawHtml.replace(/<em[^>]*>/g, '*').replace(/<\/em>/g, '*');
            processedText = processedText.replace(/<[^>]+>/g, '');
            return processedText.trim();
        }

        // 한국 시간 형식으로 날짜/시간 문자열을 생성하는 함수
        function getFormattedTimestamp() {
            const now = new Date();
            const year = now.getFullYear();
            const month = now.getMonth() + 1;
            const day = now.getDate();
            let hours = now.getHours();
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            
            const ampm = hours >= 12 ? '오후' : '오전';
            hours = hours % 12;
            hours = hours ? hours : 12; // 0시는 12시로 표시

            return `Chat Export ${year}. ${month}. ${day}. ${ampm} ${hours}:${minutes}:${seconds}`;
        }

        processBtn.addEventListener('click', function() {
            const htmlString = htmlInput.value;
            if (!htmlString.trim()) {
                outputElement.textContent = '오류: HTML 코드를 입력해주세요.';
                return;
            }

            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlString, 'text/html');
                const messageNodes = doc.querySelectorAll('[data-sentry-component="ChatMessage"]');
                
                if (messageNodes.length === 0) {
                   outputElement.textContent = '오류: 유효한 채팅 메시지를 찾을 수 없습니다.';
                   copyBtn.disabled = true;
                   downloadJsonBtn.disabled = true;
                   return;
                }

                const parsedConversation = [];
                messageNodes.forEach(node => {
                    const characterBubbles = node.querySelectorAll('[data-sentry-component="LeftContentView"]');
                    const userBubble = node.querySelector('[data-sentry-component="RightContentView"]');
                    const reversedCharacterBubbles = Array.from(characterBubbles).reverse();

                    reversedCharacterBubbles.forEach(bubble => {
                        const textElement = bubble.querySelector('.body16');
                        const textContent = processHtmlContent(textElement);
                        if (textContent) {
                            parsedConversation.push({ speaker: 'character', text: textContent });
                        }
                    });

                    if (userBubble) {
                        const textElement = userBubble.querySelector('.body16');
                        const textContent = processHtmlContent(textElement);
                        if (textContent) {
                            parsedConversation.push({ speaker: 'user', text: textContent });
                        }
                    }
                });

                parsedConversation.reverse();
                conversationData = parsedConversation; // 전역 변수에 저장

                const formattedOutput = conversationData.map(msg => {
                    const formattedText = msg.text.replace(/\n/g, '\n  ');
                    return `**${msg.speaker}:** ${formattedText}`;
                }).join('\n');

                outputElement.textContent = formattedOutput || '대화 내용을 추출하지 못했습니다.';
                copyBtn.disabled = false;
                downloadJsonBtn.disabled = false;

            } catch (error) {
                console.error('An error occurred during parsing:', error);
                outputElement.textContent = '오류가 발생했습니다. 개발자 콘솔을 확인해주세요.';
                copyBtn.disabled = true;
                downloadJsonBtn.disabled = true;
            }
        });

        copyBtn.addEventListener('click', function() {
            if (outputElement.textContent && !outputElement.textContent.startsWith('오류:')) {
                navigator.clipboard.writeText(outputElement.textContent).then(() => {
                    const originalText = copyBtn.textContent;
                    copyBtn.textContent = '복사 완료!';
                    setTimeout(() => {
                        copyBtn.textContent = originalText;
                    }, 2000);
                }).catch(err => {
                    console.error('Could not copy text: ', err);
                });
            }
        });

        downloadJsonBtn.addEventListener('click', function() {
            if (conversationData.length === 0) return;

            // JSON 형식에 맞게 데이터 가공
            const risuChatMessages = conversationData.map(msg => {
                return {
                    role: msg.speaker === 'character' ? 'char' : 'user',
                    data: msg.text
                };
            });

            const jsonObject = {
                type: "risuChat",
                ver: 2,
                data: {
                    message: risuChatMessages,
                    note: "",
                    name: getFormattedTimestamp(),
                    localLore: [],
                    fmIndex: -1,
                    id: "unknown"
                },
                folders: []
            };

            const jsonString = JSON.stringify(jsonObject, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'risuChat_export.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });
    </script>

</body>
</html>